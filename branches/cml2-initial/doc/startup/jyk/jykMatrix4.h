// --------------------------------------------------------------------------------------
// FILE: Matrix4.h
// AUTHOR: Jesse Krebs
// --------------------------------------------------------------------------------------

#ifndef JYKMATRIX4_H
#define JYKMATRIX4_H

#include "jykMath.h"
#include <ostream>

/* --------------------------------------------------------------------------------------

Some of this is duplicated in one form or another in cml::Matrix4.

-------------------------------------------------------------------------------------- */ 

namespace jyk {

template <class T = float>
class Matrix4
{
public:


    Matrix4();
    Matrix4(T m00, T m01, T m02, T m03,
            T m10, T m11, T m12, T m13,
            T m20, T m21, T m22, T m23,
            T m30, T m31, T m32, T m33);
            
    T Get(unsigned int i, unsigned int j) const;
            
            
    void Set(T m00, T m01, T m02, T m03,
             T m10, T m11, T m12, T m13,
             T m20, T m21, T m22, T m23,
             T m30, T m31, T m32, T m33);
    
    Matrix4<T>  operator-() const;
    Matrix4<T>& operator+=(const Matrix4<T>& m);
    Matrix4<T>& operator-=(const Matrix4<T>& m);
    Matrix4<T>& operator*=(const Matrix4<T>& m);
    Matrix4<T>& operator*=(T s);
    Matrix4<T>& operator/=(T s);

    friend Matrix4<T> operator+<>(const Matrix4<T>& m1, const Matrix4<T>& m2);
    friend Matrix4<T> operator-<>(const Matrix4<T>& m1, const Matrix4<T>& m2);
    friend Matrix4<T> operator*<>(const Matrix4<T>& m1, const Matrix4<T>& m2);
    friend Matrix4<T> operator*<>(const Matrix4<T>& m, T s);
    friend Matrix4<T> operator*<>(T s, const Matrix4<T>& m);
    friend Matrix4<T> operator/<>(const Matrix4<T>& m, T s);
    
    T Determinant() const;
    
    Matrix4<T> GetTranspose() const;
    void TransposeSelf();
    
    Matrix4<T> GetInverse(T epsilon = Math<T>::EPSILON) const;
    bool InvertSelf(T epsilon = Math<T>::EPSILON);

    static T Determinant(const Matrix4<T>& m);
    static Matrix4<T> Transpose(const Matrix4<T>& m);
    static Matrix4<T> Inverse(const Matrix4<T>& m);

    static const Matrix4 ZERO;
    static const Matrix4 IDENTITY;

private:

    T m_[4][4];
};
// --------------------------------------------------------------------------------------
template <class T> const Matrix4<T> Matrix4<T>::ZERO((T)0.0, (T)0.0, (T)0.0, (T)0.0,
                                                     (T)0.0, (T)0.0, (T)0.0, (T)0.0,
                                                     (T)0.0, (T)0.0, (T)0.0, (T)0.0,
                                                     (T)0.0, (T)0.0, (T)0.0, (T)0.0);
template <class T> const Matrix4<T> Matrix4<T>::IDENTITY((T)1.0, (T)0.0, (T)0.0, (T)0.0,
                                                         (T)0.0, (T)1.0, (T)0.0, (T)0.0,
                                                         (T)0.0, (T)0.0, (T)1.0, (T)0.0,
                                                         (T)0.0, (T)0.0, (T)0.0, (T)1.0);
// --------------------------------------------------------------------------------------
template <class T> Matrix4<T>::Matrix4() {}
// --------------------------------------------------------------------------------------
template <class T> Matrix4<T>::Matrix4(T m00, T m01, T m02, T m03,
                                       T m10, T m11, T m12, T m13,
                                       T m20, T m21, T m22, T m23,
                                       T m30, T m31, T m32, T m33)
{
    m_[0][0] = m00;
    m_[0][1] = m01;
    m_[0][2] = m02;
    m_[0][3] = m03;
    
    m_[1][0] = m10;
    m_[1][1] = m11;
    m_[1][2] = m12;
    m_[1][3] = m13;
    
    m_[2][0] = m20;
    m_[2][1] = m21;
    m_[2][2] = m22;
    m_[2][3] = m23;
    
    m_[3][0] = m30;
    m_[3][1] = m31;
    m_[3][2] = m32;
    m_[3][3] = m33;
}
// --------------------------------------------------------------------------------------
template <class T> T Matrix4<T>::Get(unsigned int i, unsigned int j) const
{
    assert (i < 4 && j < 4);
    
    return m_[i][j];
}
// --------------------------------------------------------------------------------------
template <class T> inline void Matrix4<T>::Set(T m00, T m01, T m02, T m03,
                                               T m10, T m11, T m12, T m13,
                                               T m20, T m21, T m22, T m23,
                                               T m30, T m31, T m32, T m33)
{
    m_[0][0] = m00;
    m_[0][1] = m01;
    m_[0][2] = m02;
    m_[0][3] = m03;
    
    m_[1][0] = m10;
    m_[1][1] = m11;
    m_[1][2] = m12;
    m_[1][3] = m13;
    
    m_[2][0] = m20;
    m_[2][1] = m21;
    m_[2][2] = m22;
    m_[2][3] = m23;
    
    m_[3][0] = m30;
    m_[3][1] = m31;
    m_[3][2] = m32;
    m_[3][3] = m33;
}
// --------------------------------------------------------------------------------------
template <class T> inline Matrix4<T> Matrix4<T>::operator-() const
{
    return Matrix4<T>(-m_[0][0], -m_[0][1], -m_[0][2], -m_[0][3],
                      -m_[1][0], -m_[1][1], -m_[1][2], -m_[1][3],
                      -m_[2][0], -m_[2][1], -m_[2][2], -m_[2][3],
                      -m_[3][0], -m_[3][1], -m_[3][2], -m_[3][3]);
}
// --------------------------------------------------------------------------------------
template <class T> inline Matrix4<T>& Matrix4<T>::operator+=(const Matrix4<T>& m)
{
    m_[0][0] += m.m_[0][0];
    m_[0][1] += m.m_[0][1];
    m_[0][2] += m.m_[0][2];
    m_[0][3] += m.m_[0][3];
    
    m_[1][0] += m.m_[1][0];
    m_[1][1] += m.m_[1][1];
    m_[1][2] += m.m_[1][2];
    m_[1][3] += m.m_[1][3];
    
    m_[2][0] += m.m_[2][0];
    m_[2][1] += m.m_[2][1];
    m_[2][2] += m.m_[2][2];
    m_[2][3] += m.m_[2][3];
    
    m_[3][0] += m.m_[3][0];
    m_[3][1] += m.m_[3][1];
    m_[3][2] += m.m_[3][2];
    m_[3][3] += m.m_[3][3];
    
    return *this;
}
// --------------------------------------------------------------------------------------
template <class T> inline Matrix4<T>& Matrix4<T>::operator-=(const Matrix4<T>& m)
{
    m_[0][0] -= m.m_[0][0];
    m_[0][1] -= m.m_[0][1];
    m_[0][2] -= m.m_[0][2];
    m_[0][3] -= m.m_[0][3];
    
    m_[1][0] -= m.m_[1][0];
    m_[1][1] -= m.m_[1][1];
    m_[1][2] -= m.m_[1][2];
    m_[1][3] -= m.m_[1][3];
    
    m_[2][0] -= m.m_[2][0];
    m_[2][1] -= m.m_[2][1];
    m_[2][2] -= m.m_[2][2];
    m_[2][3] -= m.m_[2][3];
    
    m_[3][0] -= m.m_[3][0];
    m_[3][1] -= m.m_[3][1];
    m_[3][2] -= m.m_[3][2];
    m_[3][3] -= m.m_[3][3];
    
    return *this;
}
// --------------------------------------------------------------------------------------
template <class T> inline Matrix4<T>& Matrix4<T>::operator*=(const Matrix4<T>& m)
{
    T r0, r1, r2, r3;
    
    r0 = m_[0][0];
    r1 = m_[0][1];
    r2 = m_[0][2];
    r3 = m_[0][3];
    
    m_[0][0] = r0 * m.m_[0][0] + r1 * m.m_[1][0] + r2 * m.m_[2][0] + r3 * m.m_[3][0];
    m_[0][1] = r0 * m.m_[0][1] + r1 * m.m_[1][1] + r2 * m.m_[2][1] + r3 * m.m_[3][1];
    m_[0][2] = r0 * m.m_[0][2] + r1 * m.m_[1][2] + r2 * m.m_[2][2] + r3 * m.m_[3][2];
    m_[0][3] = r0 * m.m_[0][3] + r1 * m.m_[1][3] + r2 * m.m_[2][3] + r3 * m.m_[3][3];
    
    r0 = m_[1][0];
    r1 = m_[1][1];
    r2 = m_[1][2];
    r3 = m_[1][3];
    
    m_[1][0] = r0 * m.m_[0][0] + r1 * m.m_[1][0] + r2 * m.m_[2][0] + r3 * m.m_[3][0];
    m_[1][1] = r0 * m.m_[0][1] + r1 * m.m_[1][1] + r2 * m.m_[2][1] + r3 * m.m_[3][1];
    m_[1][2] = r0 * m.m_[0][2] + r1 * m.m_[1][2] + r2 * m.m_[2][2] + r3 * m.m_[3][2];
    m_[1][3] = r0 * m.m_[0][3] + r1 * m.m_[1][3] + r2 * m.m_[2][3] + r3 * m.m_[3][3];
    
    r0 = m_[2][0];
    r1 = m_[2][1];
    r2 = m_[2][2];
    r3 = m_[2][3];
    
    m_[2][0] = r0 * m.m_[0][0] + r1 * m.m_[1][0] + r2 * m.m_[2][0] + r3 * m.m_[3][0];
    m_[2][1] = r0 * m.m_[0][1] + r1 * m.m_[1][1] + r2 * m.m_[2][1] + r3 * m.m_[3][1];
    m_[2][2] = r0 * m.m_[0][2] + r1 * m.m_[1][2] + r2 * m.m_[2][2] + r3 * m.m_[3][2];
    m_[2][3] = r0 * m.m_[0][3] + r1 * m.m_[1][3] + r2 * m.m_[2][3] + r3 * m.m_[3][3];
    
    r0 = m_[3][0];
    r1 = m_[3][1];
    r2 = m_[3][2];
    r3 = m_[3][3];
    
    m_[3][0] = r0 * m.m_[0][0] + r1 * m.m_[1][0] + r2 * m.m_[2][0] + r3 * m.m_[3][0];
    m_[3][1] = r0 * m.m_[0][1] + r1 * m.m_[1][1] + r2 * m.m_[2][1] + r3 * m.m_[3][1];
    m_[3][2] = r0 * m.m_[0][2] + r1 * m.m_[1][2] + r2 * m.m_[2][2] + r3 * m.m_[3][2];
    m_[3][3] = r0 * m.m_[0][3] + r1 * m.m_[1][3] + r2 * m.m_[2][3] + r3 * m.m_[3][3];

    return *this; 
}
// --------------------------------------------------------------------------------------
template <class T> inline Matrix4<T>& Matrix4<T>::operator*=(T s)
{
    m_[0][0] *= s;
    m_[0][1] *= s;
    m_[0][2] *= s;
    m_[0][3] *= s;
    
    m_[1][0] *= s;
    m_[1][1] *= s;
    m_[1][2] *= s;
    m_[1][3] *= s;
    
    m_[2][0] *= s;
    m_[2][1] *= s;
    m_[2][2] *= s;
    m_[2][3] *= s;
    
    m_[3][0] *= s;
    m_[3][1] *= s;
    m_[3][2] *= s;
    m_[3][3] *= s;
    
    return *this;
}
// --------------------------------------------------------------------------------------
template <class T> inline Matrix4<T>& Matrix4<T>::operator/=(T s)
{
    assert(s != (T)0.0); // Division epsilon?
    
    T invs = (T)1.0 / s;

    m_[0][0] *= invs;
    m_[0][1] *= invs;
    m_[0][2] *= invs;
    m_[0][3] *= invs;
    
    m_[1][0] *= invs;
    m_[1][1] *= invs;
    m_[1][2] *= invs;
    m_[1][3] *= invs;
    
    m_[2][0] *= invs;
    m_[2][1] *= invs;
    m_[2][2] *= invs;
    m_[2][3] *= invs;
    
    m_[3][0] *= invs;
    m_[3][1] *= invs;
    m_[3][2] *= invs;
    m_[3][3] *= invs;
    
    return *this;
}
// --------------------------------------------------------------------------------------
template <class T> inline Matrix4<T> operator+(const Matrix4<T>& m1, const Matrix4<T>& m2)
{
    return Matrix4<T>
        (m1.m_[0][0] + m2.m_[0][0], m1.m_[0][1] + m2.m_[0][1], m1.m_[0][2] + m2.m_[0][2], m1.m_[0][3] + m2.m_[0][3],
         m1.m_[1][0] + m2.m_[1][0], m1.m_[1][1] + m2.m_[1][1], m1.m_[1][2] + m2.m_[1][2], m1.m_[1][3] + m2.m_[1][3],
         m1.m_[2][0] + m2.m_[2][0], m1.m_[2][1] + m2.m_[2][1], m1.m_[2][2] + m2.m_[2][2], m1.m_[2][3] + m2.m_[2][3],
         m1.m_[3][0] + m2.m_[3][0], m1.m_[3][1] + m2.m_[3][1], m1.m_[3][2] + m2.m_[3][2], m1.m_[3][3] + m2.m_[3][3]);
}
// --------------------------------------------------------------------------------------
template <class T> inline Matrix4<T> operator-(const Matrix4<T>& m1, const Matrix4<T>& m2)
{
    return Matrix4<T>
        (m1.m_[0][0] - m2.m_[0][0], m1.m_[0][1] - m2.m_[0][1], m1.m_[0][2] - m2.m_[0][2], m1.m_[0][3] - m2.m_[0][3],
         m1.m_[1][0] - m2.m_[1][0], m1.m_[1][1] - m2.m_[1][1], m1.m_[1][2] - m2.m_[1][2], m1.m_[1][3] - m2.m_[1][3],
         m1.m_[2][0] - m2.m_[2][0], m1.m_[2][1] - m2.m_[2][1], m1.m_[2][2] - m2.m_[2][2], m1.m_[2][3] - m2.m_[2][3],
         m1.m_[3][0] - m2.m_[3][0], m1.m_[3][1] - m2.m_[3][1], m1.m_[3][2] - m2.m_[3][2], m1.m_[3][3] - m2.m_[3][3]);
}
// --------------------------------------------------------------------------------------
template <class T> inline Matrix4<T> operator*(const Matrix4<T>& m1, const Matrix4<T>& m2)
{
    return Matrix4<T>
        (m1.m_[0][0] * m2.m_[0][0] + m1.m_[0][1] * m2.m_[1][0] + m1.m_[0][2] * m2.m_[2][0] + m1.m_[0][3] * m2.m_[3][0],
         m1.m_[0][0] * m2.m_[0][1] + m1.m_[0][1] * m2.m_[1][1] + m1.m_[0][2] * m2.m_[2][1] + m1.m_[0][3] * m2.m_[3][1],
         m1.m_[0][0] * m2.m_[0][2] + m1.m_[0][1] * m2.m_[1][2] + m1.m_[0][2] * m2.m_[2][2] + m1.m_[0][3] * m2.m_[3][2],
         m1.m_[0][0] * m2.m_[0][3] + m1.m_[0][1] * m2.m_[1][3] + m1.m_[0][2] * m2.m_[2][3] + m1.m_[0][3] * m2.m_[3][3],     
         m1.m_[1][0] * m2.m_[0][0] + m1.m_[1][1] * m2.m_[1][0] + m1.m_[1][2] * m2.m_[2][0] + m1.m_[1][3] * m2.m_[3][0],
         m1.m_[1][0] * m2.m_[0][1] + m1.m_[1][1] * m2.m_[1][1] + m1.m_[1][2] * m2.m_[2][1] + m1.m_[1][3] * m2.m_[3][1],
         m1.m_[1][0] * m2.m_[0][2] + m1.m_[1][1] * m2.m_[1][2] + m1.m_[1][2] * m2.m_[2][2] + m1.m_[1][3] * m2.m_[3][2],
         m1.m_[1][0] * m2.m_[0][3] + m1.m_[1][1] * m2.m_[1][3] + m1.m_[1][2] * m2.m_[2][3] + m1.m_[1][3] * m2.m_[3][3],     
         m1.m_[2][0] * m2.m_[0][0] + m1.m_[2][1] * m2.m_[1][0] + m1.m_[2][2] * m2.m_[2][0] + m1.m_[2][3] * m2.m_[3][0],
         m1.m_[2][0] * m2.m_[0][1] + m1.m_[2][1] * m2.m_[1][1] + m1.m_[2][2] * m2.m_[2][1] + m1.m_[2][3] * m2.m_[3][1],
         m1.m_[2][0] * m2.m_[0][2] + m1.m_[2][1] * m2.m_[1][2] + m1.m_[2][2] * m2.m_[2][2] + m1.m_[2][3] * m2.m_[3][2],
         m1.m_[2][0] * m2.m_[0][3] + m1.m_[2][1] * m2.m_[1][3] + m1.m_[2][2] * m2.m_[2][3] + m1.m_[2][3] * m2.m_[3][3], 
         m1.m_[3][0] * m2.m_[0][0] + m1.m_[3][1] * m2.m_[1][0] + m1.m_[3][2] * m2.m_[2][0] + m1.m_[3][3] * m2.m_[3][0],
         m1.m_[3][0] * m2.m_[0][1] + m1.m_[3][1] * m2.m_[1][1] + m1.m_[3][2] * m2.m_[2][1] + m1.m_[3][3] * m2.m_[3][1],
         m1.m_[3][0] * m2.m_[0][2] + m1.m_[3][1] * m2.m_[1][2] + m1.m_[3][2] * m2.m_[2][2] + m1.m_[3][3] * m2.m_[3][2],
         m1.m_[3][0] * m2.m_[0][3] + m1.m_[3][1] * m2.m_[1][3] + m1.m_[3][2] * m2.m_[2][3] + m1.m_[3][3] * m2.m_[3][3]);
}
// --------------------------------------------------------------------------------------
template <class T> inline Matrix4<T> operator*(T s, const Matrix4<T>& m)
{
    return Matrix4<T>(s * m.m_[0][0], s * m.m_[0][1], s * m.m_[0][2], s * m.m_[0][3],
                      s * m.m_[1][0], s * m.m_[1][1], s * m.m_[1][2], s * m.m_[1][3],
                      s * m.m_[2][0], s * m.m_[2][1], s * m.m_[2][2], s * m.m_[2][3],
                      s * m.m_[3][0], s * m.m_[3][1], s * m.m_[3][2], s * m.m_[3][3]);
}
// --------------------------------------------------------------------------------------
template <class T> inline Matrix4<T> operator*(const Matrix4<T>& m, T s)
{
    return Matrix4<T>(m.m_[0][0] * s, m.m_[0][1] * s, m.m_[0][2] * s, m.m_[0][3] * s,
                      m.m_[1][0] * s, m.m_[1][1] * s, m.m_[1][2] * s, m.m_[1][3] * s,
                      m.m_[2][0] * s, m.m_[2][1] * s, m.m_[2][2] * s, m.m_[2][3] * s,
                      m.m_[3][0] * s, m.m_[3][1] * s, m.m_[3][2] * s, m.m_[3][3] * s);
}
// --------------------------------------------------------------------------------------
template <class T> inline Matrix4<T> operator/(const Matrix4<T>& m, T s)
{
    assert(s != (T)0.0); // Division epsilon?
    
    T invs = (T)1.0 / s;
    
    return Matrix4<T>
        (m.m_[0][0] * invs, m.m_[0][1] * invs, m.m_[0][2] * invs, m.m_[0][3] * invs,
         m.m_[1][0] * invs, m.m_[1][1] * invs, m.m_[1][2] * invs, m.m_[1][3] * invs,
         m.m_[2][0] * invs, m.m_[2][1] * invs, m.m_[2][2] * invs, m.m_[2][3] * invs,
         m.m_[3][0] * invs, m.m_[3][1] * invs, m.m_[3][2] * invs, m.m_[3][3] * invs);
}
// --------------------------------------------------------------------------------------
template <class T> Matrix4<T> Matrix4<T>::GetTranspose() const
{
    return Matrix4<T>(m_[0][0], m_[1][0], m_[2][0], m_[3][0],
                      m_[0][1], m_[1][1], m_[2][1], m_[3][1],
                      m_[0][2], m_[1][2], m_[2][2], m_[3][2],
                      m_[0][3], m_[1][3], m_[2][3], m_[3][3]);
}
// --------------------------------------------------------------------------------------
template <class T> void Matrix4<T>::TransposeSelf()
{
    T m01 = m_[0][1];
    T m02 = m_[0][2];
    T m03 = m_[0][3];
    T m12 = m_[1][2];
    T m13 = m_[1][3];
    T m23 = m_[2][3];
    
    m_[0][1] = m_[1][0];
    m_[0][2] = m_[2][0];
    m_[0][3] = m_[3][0];
    m_[1][2] = m_[2][1];
    m_[1][3] = m_[3][1];
    m_[2][3] = m_[3][2];
    
    m_[1][0] = m01;
    m_[2][0] = m02;
    m_[3][0] = m03;
    m_[2][1] = m12;
    m_[3][1] = m13;
    m_[3][2] = m23;
}
// --------------------------------------------------------------------------------------
template <class T> bool Matrix4<T>::InvertSelf(T epsilon)
{
    T det2_23_23 = m_[2][2] * m_[3][3] - m_[2][3] * m_[3][2];
    T det2_23_13 = m_[2][1] * m_[3][3] - m_[2][3] * m_[3][1];
    T det2_23_12 = m_[2][1] * m_[3][2] - m_[2][2] * m_[3][1];
    T det2_23_03 = m_[2][0] * m_[3][3] - m_[2][3] * m_[3][0];
    T det2_23_02 = m_[2][0] * m_[3][2] - m_[2][2] * m_[3][0];
    T det2_23_01 = m_[2][0] * m_[3][1] - m_[2][1] * m_[3][0];
    
    T det3_123_123 = m_[1][1] * det2_23_23 - m_[1][2] * det2_23_13 + m_[1][3] * det2_23_12;
    T det3_123_023 = m_[1][0] * det2_23_23 - m_[1][2] * det2_23_03 + m_[1][3] * det2_23_02;
    T det3_123_013 = m_[1][0] * det2_23_13 - m_[1][1] * det2_23_03 + m_[1][3] * det2_23_01;
    T det3_123_012 = m_[1][0] * det2_23_12 - m_[1][1] * det2_23_02 + m_[1][2] * det2_23_01;

    T det = m_[0][0] * det3_123_123 - m_[0][1] * det3_123_023 + m_[0][2] * det3_123_013 - m_[0][3] * det3_123_012;
    
    if (Math<T>::Fabs(det) < epsilon)
        return false;
    
    T invdet = (T)1.0 / det;

    T det2_13_23 = m_[1][2] * m_[3][3] - m_[1][3] * m_[3][2];
    T det2_13_13 = m_[1][1] * m_[3][3] - m_[1][3] * m_[3][1];
    T det2_13_12 = m_[1][1] * m_[3][2] - m_[1][2] * m_[3][1];
    T det2_13_03 = m_[1][0] * m_[3][3] - m_[1][3] * m_[3][0];
    T det2_13_02 = m_[1][0] * m_[3][2] - m_[1][2] * m_[3][0];
    T det2_13_01 = m_[1][0] * m_[3][1] - m_[1][1] * m_[3][0];
    
    T det2_12_23 = m_[1][2] * m_[2][3] - m_[1][3] * m_[2][2];
    T det2_12_13 = m_[1][1] * m_[2][3] - m_[1][3] * m_[2][1];
    T det2_12_12 = m_[1][1] * m_[2][2] - m_[1][2] * m_[2][1];
    T det2_12_03 = m_[1][0] * m_[2][3] - m_[1][3] * m_[2][0];
    T det2_12_02 = m_[1][0] * m_[2][2] - m_[1][2] * m_[2][0];
    T det2_12_01 = m_[1][0] * m_[2][1] - m_[1][1] * m_[2][0];
    
    T det3_023_123 = m_[0][1] * det2_23_23 - m_[0][2] * det2_23_13 + m_[0][3] * det2_23_12;
    T det3_023_023 = m_[0][0] * det2_23_23 - m_[0][2] * det2_23_03 + m_[0][3] * det2_23_02;
    T det3_023_013 = m_[0][0] * det2_23_13 - m_[0][1] * det2_23_03 + m_[0][3] * det2_23_01;
    T det3_023_012 = m_[0][0] * det2_23_12 - m_[0][1] * det2_23_02 + m_[0][2] * det2_23_01;
    
    T det3_013_123 = m_[0][1] * det2_13_23 - m_[0][2] * det2_13_13 + m_[0][3] * det2_13_12;
    T det3_013_023 = m_[0][0] * det2_13_23 - m_[0][2] * det2_13_03 + m_[0][3] * det2_13_02;
    T det3_013_013 = m_[0][0] * det2_13_13 - m_[0][1] * det2_13_03 + m_[0][3] * det2_13_01;
    T det3_013_012 = m_[0][0] * det2_13_12 - m_[0][1] * det2_13_02 + m_[0][2] * det2_13_01;
    
    T det3_012_123 = m_[0][1] * det2_12_23 - m_[0][2] * det2_12_13 + m_[0][3] * det2_12_12;
    T det3_012_023 = m_[0][0] * det2_12_23 - m_[0][2] * det2_12_03 + m_[0][3] * det2_12_02;
    T det3_012_013 = m_[0][0] * det2_12_13 - m_[0][1] * det2_12_03 + m_[0][3] * det2_12_01;
    T det3_012_012 = m_[0][0] * det2_12_12 - m_[0][1] * det2_12_02 + m_[0][2] * det2_12_01;

    m_[0][0] =  det3_123_123 * invdet;
    m_[1][0] = -det3_123_023 * invdet;
    m_[2][0] =  det3_123_013 * invdet;
    m_[3][0] = -det3_123_012 * invdet;
    
    m_[0][1] = -det3_023_123 * invdet;
    m_[1][1] =  det3_023_023 * invdet;
    m_[2][1] = -det3_023_013 * invdet;
    m_[3][1] =  det3_023_012 * invdet;
    
    m_[0][2] =  det3_013_123 * invdet;
    m_[1][2] = -det3_013_023 * invdet;
    m_[2][2] =  det3_013_013 * invdet;
    m_[3][2] = -det3_013_012 * invdet;
    
    m_[0][3] = -det3_012_123 * invdet;
    m_[1][3] =  det3_012_023 * invdet;
    m_[2][3] = -det3_012_013 * invdet;
    m_[3][3] =  det3_012_012 * invdet;

    return true;
}
// --------------------------------------------------------------------------------------
template <class T> T Matrix4<T>::Determinant(const Matrix4<T>& m)
{
    return m.Determinant();
}
// --------------------------------------------------------------------------------------
template <class T> Matrix4<T> Matrix4<T>::Transpose(const Matrix4<T>& m)
{
    return m.GetTranspose();
}
// --------------------------------------------------------------------------------------
template <class T> Matrix4<T> Matrix4<T>::Inverse(const Matrix4<T>& m)
{
    return m.GetInverse();
}
// --------------------------------------------------------------------------------------
template <class T> inline std::ostream& operator<<(std::ostream& os, const Matrix4<T>& m)
{
    for (int i = 0; i < 4; ++i)
    {
        os << "[ ";
        for (int j = 0; j < 4; ++j)
            os << m.Get(i, j) << " ";
        os << "]" << std::endl;
    }
    
    return os;
}
// --------------------------------------------------------------------------------------

} // namespace jyk

#endif
